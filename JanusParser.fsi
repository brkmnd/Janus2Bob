// Signature file for parser generated by fsyacc
module JanusParser
type token = 
  | SHOW of (int*int*int)
  | SIZE of (int*int*int)
  | EOI of (int*int*int)
  | EMPTY of (int*int*int)
  | TOP of (int*int*int)
  | CALL of (int*int*int)
  | UNCALL of (int*int*int)
  | LOCAL of (int*int*int)
  | DELOCAL of (int*int*int)
  | PUSH of (int*int*int)
  | POP of (int*int*int)
  | FROM of (int*int*int)
  | DO of (int*int*int)
  | LOOP of (int*int*int)
  | UNTIL of (int*int*int)
  | IF of (int*int*int)
  | THEN of (int*int*int)
  | ELSE of (int*int*int)
  | FI of (int*int*int)
  | MAIN of (int*int*int)
  | PROC of (int*int*int)
  | SKIP of (int*int*int)
  | NIL of (int*int*int)
  | INT of (int*int*int)
  | STACK of (int*int*int)
  | BIND_UP of (int*int*int)
  | BIND_PLUS of (int*int*int)
  | BIND_MINUS of (int*int*int)
  | IFF of (int*int*int)
  | PERC of (int*int*int)
  | DIV of (int*int*int)
  | AMP of (int*int*int)
  | AMPAMP of (int*int*int)
  | MID of (int*int*int)
  | MIDMID of (int*int*int)
  | PLUS of (int*int*int)
  | MINUS of (int*int*int)
  | TIMES of (int*int*int)
  | UP of (int*int*int)
  | EQ of (int*int*int)
  | NEQ of (int*int*int)
  | LT of (int*int*int)
  | GT of (int*int*int)
  | LEQ of (int*int*int)
  | GEQ of (int*int*int)
  | COMMA of (int*int*int)
  | LPAR of (int*int*int)
  | RPAR of (int*int*int)
  | LBRACKET of (int*int*int)
  | RBRACKET of (int*int*int)
  | VAL_INT of (string*(int*int*int))
  | VAL_ID of (string*(int*int*int))
type tokenId = 
    | TOKEN_SHOW
    | TOKEN_SIZE
    | TOKEN_EOI
    | TOKEN_EMPTY
    | TOKEN_TOP
    | TOKEN_CALL
    | TOKEN_UNCALL
    | TOKEN_LOCAL
    | TOKEN_DELOCAL
    | TOKEN_PUSH
    | TOKEN_POP
    | TOKEN_FROM
    | TOKEN_DO
    | TOKEN_LOOP
    | TOKEN_UNTIL
    | TOKEN_IF
    | TOKEN_THEN
    | TOKEN_ELSE
    | TOKEN_FI
    | TOKEN_MAIN
    | TOKEN_PROC
    | TOKEN_SKIP
    | TOKEN_NIL
    | TOKEN_INT
    | TOKEN_STACK
    | TOKEN_BIND_UP
    | TOKEN_BIND_PLUS
    | TOKEN_BIND_MINUS
    | TOKEN_IFF
    | TOKEN_PERC
    | TOKEN_DIV
    | TOKEN_AMP
    | TOKEN_AMPAMP
    | TOKEN_MID
    | TOKEN_MIDMID
    | TOKEN_PLUS
    | TOKEN_MINUS
    | TOKEN_TIMES
    | TOKEN_UP
    | TOKEN_EQ
    | TOKEN_NEQ
    | TOKEN_LT
    | TOKEN_GT
    | TOKEN_LEQ
    | TOKEN_GEQ
    | TOKEN_COMMA
    | TOKEN_LPAR
    | TOKEN_RPAR
    | TOKEN_LBRACKET
    | TOKEN_RBRACKET
    | TOKEN_VAL_INT
    | TOKEN_VAL_ID
    | TOKEN_end_of_input
    | TOKEN_error
type nonTerminalId = 
    | NONTERM__startstart_entry
    | NONTERM_start_entry
    | NONTERM_prog
    | NONTERM_d
    | NONTERM_t
    | NONTERM_p_main
    | NONTERM_declare
    | NONTERM_p
    | NONTERM_p_args
    | NONTERM_s_comp
    | NONTERM_s
    | NONTERM_call_args
    | NONTERM_e
    | NONTERM_e_lit
    | NONTERM_e_p_buildin
    | NONTERM_c
    | NONTERM_bind_op
    | NONTERM_x
    | NONTERM_x_arg
    | NONTERM_q
/// This function maps tokens to integer indexes
val tagOfToken: token -> int

/// This function maps integer indexes to symbolic token ids
val tokenTagToTokenId: int -> tokenId

/// This function maps production indexes returned in syntax errors to strings representing the non terminal that would be produced by that production
val prodIdxToNonTerminal: int -> nonTerminalId

/// This function gets the name of a token as a string
val token_to_string: token -> string
val start_entry : (FSharp.Text.Lexing.LexBuffer<'cty> -> token) -> FSharp.Text.Lexing.LexBuffer<'cty> -> (Prg) 
